[comment {-*- tcl -*- doctools manpage}]
[manpage_begin tcl-hwloc n 0.1]
[copyright {2011 George Andreou, Andreas Kupries}]
[copyright {2011 Documentation, Andreas Kupries}]
[moddesc   {Tcl Hwloc}]
[titledesc {Tcl Hwloc Binding}]
[require Tcl 8.5]
[require tclhwloc [opt 0.1]]
[description]
[keywords hwloc {portable hardware locality} {hardware Locality}]
[keywords {memory binding} {binding memory}]
[keywords {cpu binding} {binding cpu}]
[keywords numa multi-core thread process parallel beowulf cache]
[keywords {processing unit}]

This package is a binding to the
[uri http://www.open-mpi.org/projects/hwloc/ "Portable Hardware Locality"]
library (short: hwloc), making its functionality available to Tcl scripts.

[comment =====================================================================]
[section {Class API}]

The main API provides three methods, to retrive version information, create
topology instances, and manipulate bitmaps.

[list_begin definitions]

[call [cmd hwloc] [method bitmap] [arg ...]]

This ensemble provides a set of methods for the manipulation of hwloc bitmaps.
More details about the individual submethods are available in section
[sectref {Bitmap API}].

[call [cmd hwloc] [method create] [arg object] [arg ...]]

This method creates a new topology object whose associated instance command
has the name [arg object]. 

The creation process can be influenced by a number of options:

[list_begin options]
[opt_def -ignore_all_keep_structure]

Create a topology which ignores, i.e. excludes all objects which do not provide
any structure to it. An object does not provide structure if it is the single child
of its parent, and/or has only a single child of its own.

[opt_def -ignore_type [arg type]]

Create a topology which excludes objects of the specified type.
Note that the toplevel object of a topology is never ignored, even if it is
of the specified type. Note further that objects of type "pu" cannot be excluded.

[list_begin definitions]
[def [const system]]
[def [const machine]]
[def [const node]]
[def [const socket]]
[def [const cache]]
[def [const core]]
[def [const pu]]
[def [const group]]
[def [const misc]]
[list_end]

This list may be incomplete, with newer versions of the underlying hwloc
library definining more types. The above is based on 

[uri http://www.open-mpi.org/projects/hwloc/doc/v1.2.1/group__hwlocality__types.php \
     {hwloc version 1.2.1.}]

[opt_def -ignore_type_keep_structure]

Similar to option [option -ignore_type], however the objects of the specified type
are excluded if and only if they do not provide structure to the topology.

[opt_def -set_flags [arg flags]]

The argument is a list of values.
The acceptable flags, and their meaning are:

[list_begin definitions]
[def [const this_system]]

Assume that the selected backend provides the topology for the system
on which we are running. This forces the instance method
[method ...] to return [const true], i.e. makes hwloc assume that the
selected backend provides the topology for the system on which we are
running, even if it is not the OS-specific backend but the XML backend
for instance. This means making the binding functions actually call the
OS-specific system calls and really do binding, while the XML backend
would otherwise provide empty hooks just returning success.

[para] Setting the environment variable [var HWLOC_THISSYSTEM] may also
result in the same behavior.

[para] This can be used for efficiency reasons to first detect the
topology once, save it to an XML file, and quickly reload it later
through the XML backend, but still having binding functions actually
do bind.

[def [const whole_system]]

Detect the whole system, ignore reservations and offline settings.
Gather all resources, even if some were disabled by the administrator.
For instance, ignore Linux Cpusets and gather all processors and
memory nodes, and ignore the fact that some resources may be offline.

[list_end]

[opt_def -set_fsroot [arg path]]

Make [arg path] the filesystem root while retrieving the topology.

[para] On Linux systems, use sysfs and procfs files as if they were
mounted on the given [arg path] instead of the main file-system root.
Setting the environment variable [var HWLOC_FSROOT] may also result
in this behavior. Not using the main file-system root causes the
instance method [method local] to later return [const false].

[para] Note: For convenience, this backend provides empty binding hooks
which just return success. To have hwloc still actually call
OS-specific hooks, the flag [const this_system] has to be set (see
option [option -set_flags]) to assert that the loaded file is really
the underlying system.

[opt_def -set_pid [arg int]]

Set the process id from which to view and build the topology.

[para] On some systems, processes may have different views of the
machine, for instance the set of allowed CPUs. By default, hwloc
exposes the view from the current process. Using [option -set_pid]
forces it to expose the topology of the machine from the point of
view of another process.


[opt_def -set_synthetic [arg description]]

Create a synthetic topology from the [arg description].

This should be a space-separated string of numbers describing the
arity of each level. Each number may be prefixed with a type and
a colon to enforce the type of a level. If only some level types
are enforced, hwloc will try to choose the other types according
to usual topologies. It may fail however and you may have to
specify more level types manually.

[opt_def -set_xml [arg path]]

Create the topology not from from the system, but the XML-based
description found in the file [arg path].

[para] Setting the environment variable [var HWLOC_XMLFILE] may
also result in this behavior. This file may have been generated
earlier by exporting a topology instance as XML.

[list_end]

[call [cmd hwloc] [method version]]

This method returns HWloc's API version as its result.

[list_end]


[comment =====================================================================]
[section {Bitmap API}]

The methods in this section all deals with hwloc's bitmaps, which are
used to represent sets of nodes, cpus, etc. An important thing to note
is that such bitmaps can be infinite, in the sense that a finite
header may be followed by an infinite trailer of 1-bits (with no
0-bits anymore).

[list_begin definitions]
[comment ---------------------------------------------------------------------]
[call [cmd {hwloc bitmap}] [method empty]]
[call [cmd {hwloc bitmap}] [method full]]

These two methods return the empty (No bits set) and full (All bits set,
infinite) bitmaps, respectively. 

[comment ---------------------------------------------------------------------]
[call [cmd {hwloc bitmap}] [method allbut] [arg id]]
[call [cmd {hwloc bitmap}] [method only] [arg id]]

These two methods return bitmaps with a single bit unset ([method allbut])
or set ([method only]). The result of [method allbut] is an infinite bitmap.
The methods throw an error if a negative [arg id] is specified.

[comment ---------------------------------------------------------------------]
[call [cmd {hwloc bitmap}] [method first] [arg bitmap]]

This method returns the id of the first set bit found in the [arg bitmap],
counting up from bit 0. The method will throw an error if the [arg bitmap]
is empty, i.e. has no bit set at all.

[call [cmd {hwloc bitmap}] [method last] [arg bitmap]]

This method returns the id of the last set bit found in the [arg bitmap],
counting up from bit 0. The method will throw an error if the [arg bitmap]
is either empty, i.e. has no bit set at all, or infinite, i.e. has no
defined "last" bit.

[call [cmd {hwloc bitmap}] [method next] [arg bitmap] [arg prev]]

This method, like [method first], returns the id of the first set bit found
in the [arg bitmap], however all bits up to and including bit [arg prev] are
ignored. Negative values for [arg prev] are allowed.

[para] The method will throw an error if the [arg bitmap] is empty, i.e.
has no bit set at all, or if it is empty after bit [arg prev].

[para] The method [method first] is, in essence, the same as [method next]
called with "prev == [const -1]", i.e.

[example {
    [first bitmap] == [next bitmap -1]
}]

[comment ---------------------------------------------------------------------]
[call [cmd {hwloc bitmap}] [method from_ulong] [arg mask]]

This method takes an unsigned integer and converts it into a bitmap, based on
the integer's binary representation. The LSB is mapped to bit 0 of the bitmap.

[call [cmd {hwloc bitmap}] [method to_ulong] [arg bitmap]]

This method is the complement to [method from_ulong], converting the [arg bitmap]
into an unsigned integer value represented by the bits of the map.

[comment ---------------------------------------------------------------------]
[call [cmd {hwloc bitmap}] [method is_empty] [arg bitmap]]
[call [cmd {hwloc bitmap}] [method is_full] [arg bitmap]]

These two methods test if the specified [arg bitmap] is either the empty or the
full bitmap, i.e. no bits sets vs. all bits set, respectively. The result of the
methods is a boolean value, [const true] if the test succeeds, and [const false]
otherwise.

[comment ---------------------------------------------------------------------]
[call [cmd {hwloc bitmap}] [method not] [arg bitmap]]

This method takes the [arg bitmap], inverts all bits, and returns this as its
result.

[comment ---------------------------------------------------------------------]
[call [cmd {hwloc bitmap}] [method singlify] [arg bitmap]]

This method is similar to [method first], except that its result is a bitmap,
not a bit number, and it accepts the empty bitmap. In the resulting bitmap all
bits but the first set bit of the input are unset. If the input is empty the
output is simply empty as well.

[comment ---------------------------------------------------------------------]
[call [cmd {hwloc bitmap}] [method weight] [arg bitmap]]

This method counts the number of set bits in the specified [arg bitmap] and
returns this as its result. The method will throw an error if the [arg bitmap]
is infinite, i.e. has not a bounded weight.

[comment ---------------------------------------------------------------------]
[call [cmd {hwloc bitmap}] [method and] [arg bitmap1] [arg bitmap2]]
[call [cmd {hwloc bitmap}] [method andnot] [arg bitmap1] [arg bitmap2]]
[call [cmd {hwloc bitmap}] [method or] [arg bitmap1] [arg bitmap2]]
[call [cmd {hwloc bitmap}] [method xor] [arg bitmap1] [arg bitmap2]]

These four methods perform standard bitwise operations on the two bitmaps,
returning the operations' result. See the following mapping to C expressions:

[example {
    and    A B == A & B
    andnot A B == A & ~B
    or     A B == A | B
    xor    A B == A ^ B
}]

[comment ---------------------------------------------------------------------]
[call [cmd {hwloc bitmap}] [method is_equal] [arg bitmap1] [arg bitmap2]]

This method tests if the two specified bitmaps are equal in all respects.
The result of the method is a boolean value, [const true] if the bitmaps
are equal, and [const false] otherwise.

[comment ---------------------------------------------------------------------]
[call [cmd {hwloc bitmap}] [method is_included] [arg bitmapsub] [arg bitmapsuper]]

This method tests if [arg bitmapsub] is a subset of [arg bitmapsuper].
The result of the method is a boolean value, [const true] if the bitmap
is a subset, and [const false] otherwise.

[comment ---------------------------------------------------------------------]
[call [cmd {hwloc bitmap}] [method compare] [arg bitmap1] [arg bitmap2]]
[call [cmd {hwloc bitmap}] [method compare_first] [arg bitmap1] [arg bitmap2]]

These two method compare the two bitmaps by comparing the last and first set
bits respectively. The result of the methods are the difference between the
ids of these bits. The empty bitmap is treated as if it had bit [const -1] set.

[comment {
    It is unclear how 'compare' works for infinite bitmaps, with their
    undefined last bit
}]

[comment ---------------------------------------------------------------------]
[call [cmd {hwloc bitmap}] [method intersects] [arg bitmap1] [arg bitmap2]]

This method tests if the two specified bitmaps intersect with each other, i.e if
the result of [method and]'ing them together is not empty. The result of the method
is a boolean value, [const true] if the bitmaps have a non-empty intersection,
and [const false] otherwise.

[comment ---------------------------------------------------------------------]
[call [cmd {hwloc bitmap}] [method set] [arg bitmap] [arg id]]
[call [cmd {hwloc bitmap}] [method clear] [arg bitmap] [arg id]]
[call [cmd {hwloc bitmap}] [method is_set] [arg bitmap] [arg id]]

These three methods set, unset, and test the bits in a [arg bitmap]. The
first two methods return the modified bitmap as result, whereas the last
returns a boolean value, [const true] if the bit is set, and [arg false]
otherwise. The methods throw an error if a negative [arg id] is specified.

[comment ---------------------------------------------------------------------]
[call [cmd {hwloc bitmap}] [method set_range] [arg bitmap] [arg begin] [arg end]]
[call [cmd {hwloc bitmap}] [method clear_range] [arg bitmap] [arg begin] [arg end]]

These two methods are extensions of the modifiers in the previous group from
single bits to bit ranges. The range of bits to set or clear is specified by two
bit ids. The methods return the modified bitmap as their result.

The methods throw an error if a negative id is specified, for either [arg begin]
or [arg end]. Specifying an [arg end] < [arg begin] is acceptable however, this
specifies an empty range and the method will return the unmodified [arg bitmap].

[list_end]

[comment =====================================================================]
[section {Instance API}]
[list_begin definitions]


[call [cmd ...] [arg ...]]


[list_end]
[manpage_end]

