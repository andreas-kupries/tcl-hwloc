
<html><head>
<title>tcl-hwloc - Tcl Hwloc</title>
<style type="text/css"><!--
    HTML {
	background: 	#FFFFFF;
	color: 		black;
    }
    BODY {
	background: 	#FFFFFF;
	color:	 	black;
    }
    DIV.doctools {
	margin-left:	10%;
	margin-right:	10%;
    }
    DIV.doctools H1,DIV.doctools H2 {
	margin-left:	-5%;
    }
    H1, H2, H3, H4 {
	margin-top: 	1em;
	font-family:	sans-serif;
	font-size:	large;
	color:		#005A9C;
	background: 	transparent;
	text-align:		left;
    }
    H1.title {
	text-align: center;
    }
    UL,OL {
	margin-right: 0em;
	margin-top: 3pt;
	margin-bottom: 3pt;
    }
    UL LI {
	list-style: disc;
    }
    OL LI {
	list-style: decimal;
    }
    DT {
	padding-top: 	1ex;
    }
    UL.toc,UL.toc UL, UL.toc UL UL {
	font:		normal 12pt/14pt sans-serif;
	list-style:	none;
    }
    LI.section, LI.subsection {
	list-style: 	none;
	margin-left: 	0em;
	text-indent:	0em;
	padding: 	0em;
    }
    PRE {
	display: 	block;
	font-family:	monospace;
	white-space:	pre;
	margin:		0%;
	padding-top:	0.5ex;
	padding-bottom:	0.5ex;
	padding-left:	1ex;
	padding-right:	1ex;
	width:		100%;
    }
    PRE.example {
	color: 		black;
	background: 	#f5dcb3;
	border:		1px solid black;
    }
    UL.requirements LI, UL.syntax LI {
	list-style: 	none;
	margin-left: 	0em;
	text-indent:	0em;
	padding:	0em;
    }
    DIV.synopsis {
	color: 		black;
	background: 	#80ffff;
	border:		1px solid black;
	font-family:	serif;
	margin-top: 	1em;
	margin-bottom: 	1em;
    }
    UL.syntax {
	margin-top: 	1em;
	border-top:	1px solid black;
    }
    UL.requirements {
	margin-bottom: 	1em;
	border-bottom:	1px solid black;
    }
--></style>
</head>
<! -- Generated from file 'tcl-hwloc.man' by tcllib/doctools with format 'html'
   -->
<! -- Copyright &copy; 2011 George Andreou, Andreas Kupries   -- Copyright &copy; 2011 Documentation, Andreas Kupries
   -->
<! -- CVS: $Id$ tcl-hwloc.n
   -->
<body><div class="doctools">
<h1 class="title">tcl-hwloc(n) 0.2 tcl-hwloc &quot;Tcl Hwloc&quot;</h1>
<div id="name" class="section"><h2><a name="name">Name</a></h2>
<p>tcl-hwloc - Tcl Hwloc Binding</p>
</div>
<div id="toc" class="section"><h2><a name="toc">Table Of Contents</a></h2>
<ul class="toc">
<li class="section"><a href="#toc">Table Of Contents</a></li>
<li class="section"><a href="#synopsis">Synopsis</a></li>
<li class="section"><a href="#section1">Description</a></li>
<li class="section"><a href="#section2">Concepts</a></li>
<li class="section"><a href="#section3">Class API</a></li>
<li class="section"><a href="#section4">Instance API</a></li>
<li class="section"><a href="#section5">Bitmap API</a></li>
<li class="section"><a href="#section6">Element Identifiers</a></li>
<li class="section"><a href="#section7">References</a></li>
<li class="section"><a href="#keywords">Keywords</a></li>
<li class="section"><a href="#copyright">Copyright</a></li>
</ul>
</div>
<div id="synopsis" class="section"><h2><a name="synopsis">Synopsis</a></h2>
<div class="synopsis">
<ul class="requirements">
<li>package require <b class="pkgname">Tcl 8.5</b></li>
<li>package require <b class="pkgname">tclhwloc <span class="opt">?0.2?</span></b></li>
</ul>
<ul class="syntax">
<li><a href="#1"><b class="cmd">hwloc</b> <b class="method">bitmap</b> <i class="arg">...</i></a></li>
<li><a href="#2"><b class="cmd">hwloc</b> <b class="method">create</b> <i class="arg">object</i> <i class="arg">...</i></a></li>
<li><a href="#3"><b class="cmd">hwloc</b> <b class="method">types</b></a></li>
<li><a href="#4"><b class="cmd">hwloc</b> <b class="method">version</b></a></li>
<li><a href="#5"><b class="cmd">topologyCmd</b> <b class="method">convert 2cpuset</b> <span class="opt">?<b class="option">-strict</b>?</span> <i class="arg">set</i></a></li>
<li><a href="#6"><b class="cmd">topologyCmd</b> <b class="method">convert 2nodeset</b> <span class="opt">?<b class="option">-strict</b>?</span> <i class="arg">set</i></a></li>
<li><a href="#7"><b class="cmd">topologyCmd</b> <b class="method">cpubind get</b> <span class="opt">?options...?</span></a></li>
<li><a href="#8"><b class="cmd">topologyCmd</b> <b class="method">cpubind last</b> <span class="opt">?options...?</span></a></li>
<li><a href="#9"><b class="cmd">topologyCmd</b> <b class="method">cpubind set</b> <span class="opt">?options...?</span> <i class="arg">cpuset</i></a></li>
<li><a href="#10"><b class="cmd">topologyCmd</b> <b class="method">cpuset allowed</b></a></li>
<li><a href="#11"><b class="cmd">topologyCmd</b> <b class="method">cpuset complete</b></a></li>
<li><a href="#12"><b class="cmd">topologyCmd</b> <b class="method">cpuset online</b></a></li>
<li><a href="#13"><b class="cmd">topologyCmd</b> <b class="method">cpuset topology</b></a></li>
<li><a href="#14"><b class="cmd">topologyCmd</b> <b class="method">depth</b> <span class="opt">?<i class="arg">type</i>?</span></a></li>
<li><a href="#15"><b class="cmd">topologyCmd</b> <b class="method">destroy</b></a></li>
<li><a href="#16"><b class="cmd">topologyCmd</b> <b class="method">export</b> <i class="arg">path</i></a></li>
<li><a href="#17"><b class="cmd">topologyCmd</b> <b class="method">local</b></a></li>
<li><a href="#18"><b class="cmd">topologyCmd</b> <b class="method">membind get</b> <span class="opt">?options...?</span></a></li>
<li><a href="#19"><b class="cmd">topologyCmd</b> <b class="method">membind set</b> <span class="opt">?options...?</span> <i class="arg">nodeset</i> <i class="arg">policy</i></a></li>
<li><a href="#20"><b class="cmd">topologyCmd</b> <b class="method">nodeset allowed</b></a></li>
<li><a href="#21"><b class="cmd">topologyCmd</b> <b class="method">nodeset complete</b></a></li>
<li><a href="#22"><b class="cmd">topologyCmd</b> <b class="method">nodeset topology</b></a></li>
<li><a href="#23"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <i class="arg">...</i></a></li>
<li><a href="#24"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">arity</b></a></li>
<li><a href="#25"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">attributes</b></a></li>
<li><a href="#26"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">children</b></a></li>
<li><a href="#27"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">cpuset allowed</b></a></li>
<li><a href="#28"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">cpuset complete</b></a></li>
<li><a href="#29"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">cpuset online</b></a></li>
<li><a href="#30"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">cpuset topology</b></a></li>
<li><a href="#31"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">depth</b></a></li>
<li><a href="#32"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">first_child</b></a></li>
<li><a href="#33"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">info</b></a></li>
<li><a href="#34"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">last_child</b></a></li>
<li><a href="#35"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">logical_index</b></a></li>
<li><a href="#36"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">name</b></a></li>
<li><a href="#37"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">next_cousin</b></a></li>
<li><a href="#38"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">next_sibling</b></a></li>
<li><a href="#39"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">nodeset allowed</b></a></li>
<li><a href="#40"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">nodeset complete</b></a></li>
<li><a href="#41"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">nodeset topology</b></a></li>
<li><a href="#42"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">parent</b></a></li>
<li><a href="#43"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">prev_cousin</b></a></li>
<li><a href="#44"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">prev_sibling</b></a></li>
<li><a href="#45"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">sibling_rank</b></a></li>
<li><a href="#46"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">type</b></a></li>
<li><a href="#47"><b class="cmd">topologyCmd</b> <b class="method">element_by</b> <b class="option">-depth</b> <i class="arg">depth</i> <i class="arg">index</i></a></li>
<li><a href="#48"><b class="cmd">topologyCmd</b> <b class="method">element_by</b> <b class="option">-type</b> <i class="arg">type</i> <i class="arg">index</i></a></li>
<li><a href="#49"><b class="cmd">topologyCmd</b> <b class="method">root</b></a></li>
<li><a href="#50"><b class="cmd">topologyCmd</b> <b class="method">type</b> <i class="arg">depth</i></a></li>
<li><a href="#51"><b class="cmd">topologyCmd</b> <b class="method">width</b> <i class="arg">type</i></a></li>
<li><a href="#52"><b class="cmd">topologyCmd</b> <b class="method">width</b> <i class="arg">depth</i></a></li>
<li><a href="#53"><b class="cmd">hwloc bitmap</b> <b class="method">empty</b></a></li>
<li><a href="#54"><b class="cmd">hwloc bitmap</b> <b class="method">full</b></a></li>
<li><a href="#55"><b class="cmd">hwloc bitmap</b> <b class="method">allbut</b> <i class="arg">id</i></a></li>
<li><a href="#56"><b class="cmd">hwloc bitmap</b> <b class="method">only</b> <i class="arg">id</i></a></li>
<li><a href="#57"><b class="cmd">hwloc bitmap</b> <b class="method">first</b> <i class="arg">bitmap</i></a></li>
<li><a href="#58"><b class="cmd">hwloc bitmap</b> <b class="method">last</b> <i class="arg">bitmap</i></a></li>
<li><a href="#59"><b class="cmd">hwloc bitmap</b> <b class="method">next</b> <i class="arg">bitmap</i> <i class="arg">prev</i></a></li>
<li><a href="#60"><b class="cmd">hwloc bitmap</b> <b class="method">from_ulong</b> <i class="arg">mask</i></a></li>
<li><a href="#61"><b class="cmd">hwloc bitmap</b> <b class="method">to_ulong</b> <i class="arg">bitmap</i></a></li>
<li><a href="#62"><b class="cmd">hwloc bitmap</b> <b class="method">is_empty</b> <i class="arg">bitmap</i></a></li>
<li><a href="#63"><b class="cmd">hwloc bitmap</b> <b class="method">is_full</b> <i class="arg">bitmap</i></a></li>
<li><a href="#64"><b class="cmd">hwloc bitmap</b> <b class="method">not</b> <i class="arg">bitmap</i></a></li>
<li><a href="#65"><b class="cmd">hwloc bitmap</b> <b class="method">singlify</b> <i class="arg">bitmap</i></a></li>
<li><a href="#66"><b class="cmd">hwloc bitmap</b> <b class="method">weight</b> <i class="arg">bitmap</i></a></li>
<li><a href="#67"><b class="cmd">hwloc bitmap</b> <b class="method">and</b> <i class="arg">bitmap1</i> <i class="arg">bitmap2</i></a></li>
<li><a href="#68"><b class="cmd">hwloc bitmap</b> <b class="method">andnot</b> <i class="arg">bitmap1</i> <i class="arg">bitmap2</i></a></li>
<li><a href="#69"><b class="cmd">hwloc bitmap</b> <b class="method">or</b> <i class="arg">bitmap1</i> <i class="arg">bitmap2</i></a></li>
<li><a href="#70"><b class="cmd">hwloc bitmap</b> <b class="method">xor</b> <i class="arg">bitmap1</i> <i class="arg">bitmap2</i></a></li>
<li><a href="#71"><b class="cmd">hwloc bitmap</b> <b class="method">is_equal</b> <i class="arg">bitmap1</i> <i class="arg">bitmap2</i></a></li>
<li><a href="#72"><b class="cmd">hwloc bitmap</b> <b class="method">is_included</b> <i class="arg">bitmapsub</i> <i class="arg">bitmapsuper</i></a></li>
<li><a href="#73"><b class="cmd">hwloc bitmap</b> <b class="method">compare</b> <i class="arg">bitmap1</i> <i class="arg">bitmap2</i></a></li>
<li><a href="#74"><b class="cmd">hwloc bitmap</b> <b class="method">compare_first</b> <i class="arg">bitmap1</i> <i class="arg">bitmap2</i></a></li>
<li><a href="#75"><b class="cmd">hwloc bitmap</b> <b class="method">intersects</b> <i class="arg">bitmap1</i> <i class="arg">bitmap2</i></a></li>
<li><a href="#76"><b class="cmd">hwloc bitmap</b> <b class="method">set</b> <i class="arg">bitmap</i> <i class="arg">id</i></a></li>
<li><a href="#77"><b class="cmd">hwloc bitmap</b> <b class="method">clear</b> <i class="arg">bitmap</i> <i class="arg">id</i></a></li>
<li><a href="#78"><b class="cmd">hwloc bitmap</b> <b class="method">is_set</b> <i class="arg">bitmap</i> <i class="arg">id</i></a></li>
<li><a href="#79"><b class="cmd">hwloc bitmap</b> <b class="method">set_range</b> <i class="arg">bitmap</i> <i class="arg">begin</i> <i class="arg">end</i></a></li>
<li><a href="#80"><b class="cmd">hwloc bitmap</b> <b class="method">clear_range</b> <i class="arg">bitmap</i> <i class="arg">begin</i> <i class="arg">end</i></a></li>
</ul>
</div>
</div>
<div id="section1" class="section"><h2><a name="section1">Description</a></h2>
<p>This package is a binding to the
<a href="http://www.open-mpi.org/projects/hwloc/">Portable Hardware Locality</a>
library (short: hwloc), making its functionality available to Tcl scripts.</p>
</div>
<div id="section2" class="section"><h2><a name="section2">Concepts</a></h2>
<p>Information about most of the concepts needed to handle hwloc can be
found at its website, in particular at
<a href="http://www.open-mpi.org/projects/hwloc/doc/v1.2.1/modules.php">http://www.open-mpi.org/projects/hwloc/doc/v1.2.1/modules.php</a>
and equivalent urls for other versions of the underlying package.</p>
<p>Because of this only an abridged summary is provided here, with
the expectation that searchers for deeper knowledge will go to the
above site.</p>
<p>At the heart of the package is the <i class="term">topology</i>, an object
which encapsulates a whole system and its configuration, i.e. the
<i class="term">elements</i> it consists of, and their relationships.
The latter is modeled as a tree, with the relation of &quot;X is child of
Y&quot; meaning &quot;X is (conceptually) contained in Y&quot;.
This puts the whole system at the top, as the root of the tree, and
the most basic processing elements at the bottom, contained in a
hierarchy of <i class="term">caches</i>, <i class="term">cpus</i>, <i class="term">sockets</i>, and the like.</p>
<p>This same tree can also be viewed as a <i class="term">matrix</i>, with each
row representing a layer of the system, from the processing elements
up to the whole system. This second view is especially useful for
identifying and adressing each of the elements in the topology, as two
numbers are sufficient for this, the depth in the hierachy (counting
up while going down from the top), and an index in the layer (counting
up from the left).</p>
<p>An important side note here is that all elements in a layer are
of the same type, which also allows addressing by type, with the depth
implied by it. At least for elements usually existing only in a single
layer. A good counter example are caches, which may occupy more than
one layer, representing the hierarchy of cache levels in the system.</p>
<p>Beyond simple introspection of the system's configuration the
package also enables its user to pin processes and threads to specific
parts of the system, either in terms of logical processors, or in
terms of memory. The former is more relevant for multi-macore
machines, and the latter for NUMA machines.
The central concepts there are cpu and (memory) node sets, both of
which are represented by (possibly infinite) <i class="term">bitmaps</i>.
Conversion between both types is possible, as is going from topology
elements to cpu sets.</p>
</div>
<div id="section3" class="section"><h2><a name="section3">Class API</a></h2>
<p>The main API provides three methods, to retrive version information, create
topology instances, and manipulate bitmaps.</p>
<dl class="definitions">
<dt><a name="1"><b class="cmd">hwloc</b> <b class="method">bitmap</b> <i class="arg">...</i></a></dt>
<dd><p>This ensemble provides a set of methods for the manipulation of hwloc bitmaps.
More details about the individual submethods are available in section
<span class="sectref"><a href="#section5">Bitmap API</a></span>.</p></dd>
<dt><a name="2"><b class="cmd">hwloc</b> <b class="method">create</b> <i class="arg">object</i> <i class="arg">...</i></a></dt>
<dd><p>This method creates a new topology object whose associated instance command
has the name <i class="arg">object</i>. 
The creation process can be influenced by a number of options:</p>
<dl class="options">
<dt><b class="option">-ignore_all_keep_structure</b></dt>
<dd><p>Create a topology which ignores, i.e. excludes, all elements which do
not provide any structure to it. An element does not provide structure
if it is the single child of its parent, and/or has only a single
child of its own.</p></dd>
<dt><b class="option">-ignore_type</b> <i class="arg">type</i></dt>
<dd><p>Create a topology which excludes elements of the specified type.  Note
that the toplevel element of a topology is never ignored, even if it
is of the specified type. Note further that elements of type &quot;pu&quot;
cannot be excluded.
The list of valid element types can be retrieved via <b class="cmd">hwloc types</b>. The exact
list depends on the version of Hwloc the binding is linked against (at runtime). See
<a href="http://www.open-mpi.org/projects/hwloc/doc/v1.2.1/group__hwlocality__types.php">Hwloc's documentation</a>
for the list of types handled by a specific version.</p></dd>
<dt><b class="option">-ignore_type_keep_structure</b></dt>
<dd><p>Similar to option <b class="option">-ignore_type</b>, however the elements of the
specified type are excluded if and only if they do not provide
structure to the topology.</p></dd>
<dt><b class="option">-flags</b> <i class="arg">flags</i></dt>
<dd><p>The argument is a list of values.
The acceptable flags, and their meaning are:</p>
<dl class="definitions">
<dt><b class="const">this_system</b></dt>
<dd><p>Assume that the selected backend provides the topology for the system
on which we are running. This forces the instance method
<b class="method">...</b> to return <b class="const">true</b>, i.e. makes hwloc assume that the
selected backend provides the topology for the system on which we are
running, even if it is not the OS-specific backend but the XML backend
for instance. This means making the binding functions actually call the
OS-specific system calls and really do binding, while the XML backend
would otherwise provide empty hooks just returning success.</p>
<p>Setting the environment variable <b class="variable">HWLOC_THISSYSTEM</b> may also
result in the same behavior.</p>
<p>This can be used for efficiency reasons to first detect the
topology once, save it to an XML file, and quickly reload it later
through the XML backend, but still having binding functions actually
do bind.</p></dd>
<dt><b class="const">whole_system</b></dt>
<dd><p>Detect the whole system, ignore reservations and offline settings.
Gather all resources, even if some were disabled by the administrator.
For instance, ignore Linux Cpusets and gather all processors and
memory nodes, and ignore the fact that some resources may be offline.</p></dd>
</dl></dd>
<dt><b class="option">-fsroot</b> <i class="arg">path</i></dt>
<dd><p>Make <i class="arg">path</i> the filesystem root while retrieving the topology.</p>
<p>On Linux systems, use sysfs and procfs files as if they were
mounted on the given <i class="arg">path</i> instead of the main file-system root.
Setting the environment variable <b class="variable">HWLOC_FSROOT</b> may also result
in this behavior. Not using the main file-system root causes the
instance method <b class="method">local</b> to later return <b class="const">false</b>.</p>
<p>Note: For convenience, this backend provides empty binding hooks
which just return success. To have hwloc still actually call
OS-specific hooks, the flag <b class="const">this_system</b> has to be set (see
option <b class="option">-flags</b>) to assert that the loaded file is really
the underlying system.</p></dd>
<dt><b class="option">-pid</b> <i class="arg">int</i></dt>
<dd><p>Set the process id from which to view and build the topology.</p>
<p>On some systems, processes may have different views of the
machine, for instance the set of allowed CPUs. By default, hwloc
exposes the view from the current process. Using <b class="option">-pid</b>
forces it to expose the topology of the machine from the point of
view of another process.</p></dd>
<dt><b class="option">-synthetic</b> <i class="arg">description</i></dt>
<dd><p>Create a synthetic topology from the <i class="arg">description</i>.
This should be a space-separated string of numbers describing the
arity of each level. Each number may be prefixed with a type and
a colon to enforce the type of a level. If only some level types
are enforced, hwloc will try to choose the other types according
to usual topologies. It may fail however and you may have to
specify more level types manually.</p></dd>
<dt><b class="option">-xml</b> <i class="arg">path</i></dt>
<dd><p>Create the topology not from from the system, but the XML-based
description found in the file <i class="arg">path</i>.</p>
<p>Setting the environment variable <b class="variable">HWLOC_XMLFILE</b> may
also result in this behavior. This file may have been generated
earlier by exporting a topology instance as XML.</p></dd>
</dl></dd>
<dt><a name="3"><b class="cmd">hwloc</b> <b class="method">types</b></a></dt>
<dd><p>This method returns a list containing the names of all valid element
types.</p></dd>
<dt><a name="4"><b class="cmd">hwloc</b> <b class="method">version</b></a></dt>
<dd><p>This method returns HWloc's API version as its result.</p></dd>
</dl>
</div>
<div id="section4" class="section"><h2><a name="section4">Instance API</a></h2>
<p>After the creation of a topology instance via <b class="cmd">hwloc create</b> (see section
<span class="sectref"><a href="#section3">Class API</a></span>) the instance command provides the following API and
methods:</p>
<dl class="definitions">
<dt><a name="5"><b class="cmd">topologyCmd</b> <b class="method">convert 2cpuset</b> <span class="opt">?<b class="option">-strict</b>?</span> <i class="arg">set</i></a></dt>
<dd></dd>
<dt><a name="6"><b class="cmd">topologyCmd</b> <b class="method">convert 2nodeset</b> <span class="opt">?<b class="option">-strict</b>?</span> <i class="arg">set</i></a></dt>
<dd><p>This method converts from bitmaps representing node sets to cpu sets,
and vice versa. The returned result is again a bitmap, in the other
domain.</p>
<p>If the <b class="option">-strict</b> option is specified the conversion will
punt if the topology describes a non-NUMA system without NUMA nodes,
and return an empty CPU or node, respectively.</p>
<p>Otherwise, the default, the conversion will treat the system as
a single memory node and use the following heuristics:</p>
<ol class="enumerated">
<li><p>If the input set is empty, the result will be emptied as well.</p></li>
<li><p>Otherwise the result will be entirely filled.</p></li>
</ol></dd>
<dt><a name="7"><b class="cmd">topologyCmd</b> <b class="method">cpubind get</b> <span class="opt">?options...?</span></a></dt>
<dd><p>This method returns the currently set CPU bindings for the current
process.
The behaviour can be modified by specifying one or more of the options
below:</p>
<dl class="options">
<dt><b class="option">-pid</b> <i class="arg">pid</i></dt>
<dd><p>Return the information for the referenced process instead.</p></dd>
<dt><b class="option">-process</b></dt>
<dd><p>Return the information for all threads of the (possibly multithreaded)
process.</p></dd>
<dt><b class="option">-strict</b></dt>
<dd><p>When specified the system checks whether all threads of the process
actually have the same binding. By default, the binding of each thread
will be accumulated, i.e. the union of all bindings returned.</p>
<p><em>Note</em> that this flag is meaningless when retrieving the
binding of a thread.</p></dd>
<dt><b class="option">-thread</b></dt>
<dd><p>Return the binding of the current thread of the current process. This
option cannot be used together with <b class="option">-pid</b>. I.e. when querying
a different process we cannot query that process' threads in detail.</p></dd>
</dl></dd>
<dt><a name="8"><b class="cmd">topologyCmd</b> <b class="method">cpubind last</b> <span class="opt">?options...?</span></a></dt>
<dd><p>This method returns the CPU where the current thread or process was
run last time it executed.  Note that the may be outdated, i.e. not be
the CPU it is currently running on, as the OS may have shifted it
around already according to their binding, as it saw fit.
The behaviour can be modified by specifying one or more of the options
below:</p>
<dl class="options">
<dt><b class="option">-pid</b> <i class="arg">pid</i></dt>
<dd><p>Return the information for the referenced process instead.</p></dd>
<dt><b class="option">-process</b></dt>
<dd><p>Return the information for all threads of the (possibly multithreaded)
process.</p></dd>
<dt><b class="option">-thread</b></dt>
<dd><p>Return the location of the current thread of the current process. This
option cannot be used together with <b class="option">-pid</b>. I.e. when querying
a different process we cannot query that process' threads in detail.</p></dd>
</dl></dd>
<dt><a name="9"><b class="cmd">topologyCmd</b> <b class="method">cpubind set</b> <span class="opt">?options...?</span> <i class="arg">cpuset</i></a></dt>
<dd><p>By default this method binds the current process, assumed to be
single-threaded, to the specified <i class="arg">cpuset</i>. This is the most
portable way of using this method.
The behaviour can be modified by specifying one or more of the options
below:</p>
<dl class="options">
<dt><b class="option">-nomembind</b></dt>
<dd><p>Instructs the system to not change memory bindings. I.e there are
operating systems there binding a process/thread to a (set of) CPU(s)
will also bind its memory to the associated NUMA node, by default. If
this is a problem for the process then using this flag causes the
package to avoid the OS functions which would bind memory as well.</p>
<p>Note however that depending on system configuration and OS this
may fail.</p></dd>
<dt><b class="option">-pid</b> <i class="arg">pid</i></dt>
<dd><p>Bind the referenced process instead.</p></dd>
<dt><b class="option">-process</b></dt>
<dd><p>Bind all threads of the (possibly multithreaded) process.</p></dd>
<dt><b class="option">-strict</b></dt>
<dd><p>Request a strict binding. By default, the OS may shift the process
and/or thread to CPUs it was not strictly bound to, if the designated
CPUs are busy and others are idle, to ensure progress. A strict
binding prevents this, i.e. the process or thread will never go
anywhere but the designated CPUs.</p>
<p>Note such a request may fail, as the OS may not implement this
functionality, or it may have been be disabled by the system's
administrator.</p></dd>
<dt><b class="option">-thread</b></dt>
<dd><p>Bind just the current thread of the current process. This option
cannot be used together with <b class="option">-pid</b>. I.e. when binding a
different process we have no control over how that process' threads
are bound in detail.</p></dd>
</dl></dd>
<dt><a name="10"><b class="cmd">topologyCmd</b> <b class="method">cpuset allowed</b></a></dt>
<dd></dd>
<dt><a name="11"><b class="cmd">topologyCmd</b> <b class="method">cpuset complete</b></a></dt>
<dd></dd>
<dt><a name="12"><b class="cmd">topologyCmd</b> <b class="method">cpuset online</b></a></dt>
<dd></dd>
<dt><a name="13"><b class="cmd">topologyCmd</b> <b class="method">cpuset topology</b></a></dt>
<dd><p>This method returns a bitmap describing various types of CPU sets,
i.e. subsets of the whole set of logical processors found in the
topology.</p>
<dl class="definitions">
<dt>allowed</dt>
<dd><p>All <i class="term">allowed</i> processors.</p></dd>
<dt>complete</dt>
<dd><p>All processors.</p></dd>
<dt>online</dt>
<dd><p>All <i class="term">online</i> (aka <i class="term">active</i> processors.</p></dd>
<dt>topology</dt>
<dd><p>All processors of the system.</p></dd>
</dl></dd>
<dt><a name="14"><b class="cmd">topologyCmd</b> <b class="method">depth</b> <span class="opt">?<i class="arg">type</i>?</span></a></dt>
<dd><p>This method returns the depth of the topology as an integer value, or
the depth at which the elements of the specified <i class="arg">type</i> are found.
An error is thrown if an invalid <i class="arg">type</i> is specified. A negative
value, <b class="const">-1</b> to be precise, is returned if the <i class="arg">type</i> is
valid but the topology does not contain elements of that type.</p></dd>
<dt><a name="15"><b class="cmd">topologyCmd</b> <b class="method">destroy</b></a></dt>
<dd><p>This method destroys the topology instance and underlying structures.
The result of the method is the empty string.</p></dd>
<dt><a name="16"><b class="cmd">topologyCmd</b> <b class="method">export</b> <i class="arg">path</i></a></dt>
<dd><p>This method converts the topology into a XML description and stores it
in the file <i class="arg">path</i>. This description can be loaded into a new
topology via</p>
<pre class="example">
    hwloc create X -xml path
</pre>
<p>The result of the method is the empty string.</p></dd>
<dt><a name="17"><b class="cmd">topologyCmd</b> <b class="method">local</b></a></dt>
<dd><p>This method checks if the instance is a representation of the local
system and returns a boolean value, <b class="const">true</b> if the test suceeded,
and <b class="const">false</b> otherwise. Related parts in the class API are the
option <b class="option">-flags</b> with flag <b class="const">this_system</b>, option
<b class="option">-fsroot</b> and option <b class="option">-xml</b>.</p></dd>
<dt><a name="18"><b class="cmd">topologyCmd</b> <b class="method">membind get</b> <span class="opt">?options...?</span></a></dt>
<dd><p>This method returns a 2-element list containing the currently set
default NUMA bindings and policies for a process and/or thread, in
this order. The bindings are represented by a bitmap representing
either a nodeset (default) or a cpuset.
Its behaviour can be modified by specifying one or more of the options
below:</p>
<dl class="options">
<dt><b class="option">-cpu</b></dt>
<dd><p>By default the bitmap returned by the method represents a nodeset.
When this option is specified a cpuset is returned instead, with the
method internally converting the nodeset result to it.
For convenience sake's all descriptions below talk only about
nodesets, with the conversion implied where needed.</p></dd>
<dt><b class="option">-pid</b> <i class="arg">pid</i></dt>
<dd><p>By default this method queries the current process or its threads.
When this option is specified the referenced process is queried
instead, and we lose the ability for a finegrained query of
threads. I.e. usage of option <b class="option">-thread</b> is forbidden, and
<b class="option">-process</b> is implied.</p></dd>
<dt><b class="option">-process</b></dt>
<dd></dd>
<dt><b class="option">-thread</b></dt>
<dd><p>These two options exclude each other, i.e. when using one use of the
other is forbidden.</p>
<p>By default, i.e. when neither of the options is present, the
process is assumed to be single threaded. The package will then use
either process-based OS functions or thread-based OS functions,
depending on which are available and fitting. This makes this the most
portable method.</p>
<p>Passing option <b class="option">-process</b> causes the return of the
current policies and nodesets for all the threads in the specified
process (current, or referenced by option <b class="option">-pid</b>).
The exact nature of the result depends on the presence of option
<b class="option">-strict</b>, and will be explained there.</p>
<p>Passing option <b class="option">-thread</b> specifies to return the current
policy and nodeset for the current thread invoking the method, in the
current process.
Use of this option is forbidden when option <b class="option">-pid</b> is present.</p></dd>
<dt><b class="option">-strict</b></dt>
<dd><p>The (non-)presence of this option guides the handling of multiple
threads.
In the default case of either a single-threaded process (neither
<b class="option">-process</b>, nor <b class="option">-thread</b> present) or when querying a
single thread (via <b class="option">-thread</b>) we have only a single nodeset and
policy, these are returned, and this option is ignored when specified.</p>
<p>Now when <b class="option">-process</b> or <b class="option">-pid</b> are used we are
querying (potentially) multiple threads and have to merge the nodesets
and policies in some way.
By default that is exactly what happens. The union of all found
nodesets is computed and returned. For the policies, if all are
identical this one policy is returned, and otherwise &quot;mixed&quot; is
returned.</p>
<p>By specifying this option we disable the above merging process
and replace it with a check. If the nodesets and policies of all the
queried threads are identical, then this information is returned as
usual. If there are differences however, then an error is thrown
instead.</p></dd>
</dl></dd>
<dt><a name="19"><b class="cmd">topologyCmd</b> <b class="method">membind set</b> <span class="opt">?options...?</span> <i class="arg">nodeset</i> <i class="arg">policy</i></a></dt>
<dd><p>This method sets the default memory binding <i class="arg">policy</i> and to prefer
the NUMA node(s) specified by the <i class="arg">nodeset</i>. This determines which
NUMA modes to use when allocating memory.
Its behaviour can be modified by specifying one or more of the options
below:</p>
<dl class="options">
<dt><b class="option">-migrate</b></dt>
<dd><p>If specified the package will attempt to migrate existing allocated
memory to the specified NUMA nodes.
By default failure to perform the migration is not reported. However
if the option <b class="option">-strict</b> is specified also, an error will be
thrown.</p></dd>
<dt><b class="option">-nocpubind</b></dt>
<dd><p>Specifying this option instructs the package to not change cpu
bindings. I.e there are operating systems where binding a process
and/or thread to a (set of) NUMA node(s) will also bind its execution
to the associated CPUs, by default. If this is a problem for the
process then using this flag causes the package to avoid the OS
functions which would bind cpus as well.</p>
<p>Note however that depending on system configuration and OS this
may fail.</p></dd>
<dt><b class="option">-cpu</b></dt>
<dd><p>By default the bitmap taken by the method represents a <i class="arg">nodeset</i>.
When this option is specified a cpuset is taken instead, with the
method internally converting it to a nodeset.
For convenience sake's all descriptions below talk only about
nodesets, with the conversion implied where needed.</p></dd>
<dt><b class="option">-pid</b> <i class="arg">pid</i></dt>
<dd><p>By default this method operates on the current process or its threads.
When this option is specified the referenced process is operated on
instead, and we lose the ability for a finegrained handling of
threads. I.e. usage of option <b class="option">-thread</b> is forbidden, and
<b class="option">-process</b> is implied.</p></dd>
<dt><b class="option">-thread</b></dt>
<dd></dd>
<dt><b class="option">-process</b></dt>
<dd><p>These two options exclude each other, i.e. when using one use of the
other is forbidden.</p>
<p>By default, i.e. when neither of the options is present, the
process is assumed to be single threaded. The package will then use
either process-based OS functions or thread-based OS functions,
depending on which are available and fitting. This makes this the most
portable form.</p>
<p>Passing <b class="option">-process</b> sets the policy for all threads of
the specified (possibly multithreaded) process.</p>
<p>Passing <b class="option">-thread</b> sets the policy for the current thread
of the current process.</p></dd>
<dt><b class="option">-strict</b></dt>
<dd><p>Presence of this option requests a strict binding from the OS. The
function will fail if the binding can not be guaranteed / completely
enforced.
This flag has slightly different meanings depending on the presence of
the options <b class="option">-pid</b> and <b class="option">-cpu</b>.
Hwloc's documentation doesn't go into further detail.</p></dd>
</dl>
<p>The following policies are accepted as legal. Remember however that
not all systems support all policies, and attempting an unsupported
policy causes errors to be thrown.</p>
<dl class="definitions">
<dt><b class="const">bind</b></dt>
<dd><p>Allocate memory on the specified NUMA nodes.</p></dd>
<dt><b class="const">default</b></dt>
<dd><p>Reset the memory allocation policy to the system default. This is the
only policy which is fully portable across systems.</p></dd>
<dt><b class="const">firsttouch</b></dt>
<dd><p>Allocated memory is not immediately bound to a specific locality. Each
page in the allocation is individually bound to the local NUMA node of
the first thread that touches it, at the time of this touch.</p></dd>
<dt><b class="const">interleave</b></dt>
<dd><p>Allocate the memory on the specified nodes in an interleaved /
round-robin manner. The precise layout of the memory across multiple
NUMA nodes is OS/system specific. Interleaving can be useful when
threads distributed across the specified NUMA nodes will all be
accessing the whole memory range concurrently, since the interleave
will then balance the memory references.</p></dd>
<dt><b class="const">mixed</b></dt>
<dd><p>This policy is returned when multiple threads or parts of a memory
area have differing memory binding policies. It is not usable for
setting a policy.</p></dd>
<dt><b class="const">nexttouch</b></dt>
<dd><p>For each page bound with this policy, the next time it is touched (and
next time only), it is moved from its current location to the local
NUMA node of the thread where the memory reference occurred (if it
needs to be moved at all).</p></dd>
<dt><b class="const">replicate</b></dt>
<dd><p>Replicate memory on the given nodes; reads from this memory will
attempt to be serviced from the NUMA node local to the reading
thread. Replicating can be useful when multiple threads from the
specified NUMA nodes will be sharing the same read-only data.</p></dd>
</dl></dd>
<dt><a name="20"><b class="cmd">topologyCmd</b> <b class="method">nodeset allowed</b></a></dt>
<dd></dd>
<dt><a name="21"><b class="cmd">topologyCmd</b> <b class="method">nodeset complete</b></a></dt>
<dd></dd>
<dt><a name="22"><b class="cmd">topologyCmd</b> <b class="method">nodeset topology</b></a></dt>
<dd><p>This method returns a bitmap describing various types of numa node
sets, i.e. subsets of the whole set of logical memory found in the
topology.</p>
<dl class="definitions">
<dt>allowed</dt>
<dd><p>All <i class="term">allowed</i> numa nodes.</p></dd>
<dt>complete</dt>
<dd><p>All numa nodes.</p></dd>
<dt>topology</dt>
<dd><p>All numa nodes of the system.</p></dd>
</dl></dd>
<dt><a name="23"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <i class="arg">...</i></a></dt>
<dd><p>This method provides an ensemble of sub-commands enabling navigation
in the tree of elements contained in the topology, relative to the
element specified by the <i class="arg">id</i>. See also method <b class="method">root</b>.
Please see section <span class="sectref"><a href="#section6">Element Identifiers</a></span> for details of the
syntax used here. Errors are thrown for identifiers not following this
syntax, or refering to elements not existing in the topology.</p></dd>
<dt><a name="24"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">arity</b></a></dt>
<dd><p>This method returns an integer number, the number of children for the
element.</p></dd>
<dt><a name="25"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">attributes</b></a></dt>
<dd><p>This method, and <b class="method">info</b> below return similar information, this
one more human-readable, the other machine-readable, and with a few
keys excluded. The result here is a string shell variable assignments,
separated by a single space.</p></dd>
<dt><a name="26"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">children</b></a></dt>
<dd><p>This method returns a list of element identifiers, the children of the
element. If the element hs no children the result is the empty list.</p></dd>
<dt><a name="27"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">cpuset allowed</b></a></dt>
<dd></dd>
<dt><a name="28"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">cpuset complete</b></a></dt>
<dd></dd>
<dt><a name="29"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">cpuset online</b></a></dt>
<dd></dd>
<dt><a name="30"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">cpuset topology</b></a></dt>
<dd><p>This method returns a bitmap, one of several CPU sets associated with
the element.</p>
<dl class="definitions">
<dt>allowed</dt>
<dd><p>All <i class="term">allowed</i> processors.</p></dd>
<dt>complete</dt>
<dd><p>All processors.</p></dd>
<dt>online</dt>
<dd><p>All <i class="term">online</i> (aka <i class="term">active</i> processors.</p></dd>
<dt>topology</dt>
<dd><p>All processors of the system.</p></dd>
</dl></dd>
<dt><a name="31"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">depth</b></a></dt>
<dd><p>This method returns the depth the element is at. This is, in essence,
the first element of its element identifier.</p></dd>
<dt><a name="32"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">first_child</b></a></dt>
<dd><p>This method returns the element identifier of the first, leftmost
child of the element. An error is thrown if the element has no
children.</p></dd>
<dt><a name="33"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">info</b></a></dt>
<dd><p>This method, and <b class="method">attributes</b> above return similar information,
this one machine-readable, the other more human-readable, and with a
few keys more. The result here is a list of pairs, with each pair
containing key and vaue, in this order.</p></dd>
<dt><a name="34"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">last_child</b></a></dt>
<dd><p>This method returns the element identifier of the last, rightmost
child of the element. An error is thrown if the element has no
children.</p></dd>
<dt><a name="35"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">logical_index</b></a></dt>
<dd><p>This method returns the index of the element in its layer. This is, in
essence, the second element of its element identifier.</p></dd>
<dt><a name="36"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">name</b></a></dt>
<dd><p>This method returns a string, the name of the element.</p></dd>
<dt><a name="37"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">next_cousin</b></a></dt>
<dd><p>This method returns the identifier of the right sibling of the
element, if there is any, or the first child in the next sibling of
its parent element. In essence it navigates to the right in its layer
without being bound to the children of the current parent.
The method throws an error if and only if the element is the last
element in its layer.</p></dd>
<dt><a name="38"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">next_sibling</b></a></dt>
<dd><p>This method returns the identifier of the right sibling of the
element.  The method throws an error if the element is the last child
in its parent, i.e. does not have a right sibling.</p></dd>
<dt><a name="39"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">nodeset allowed</b></a></dt>
<dd></dd>
<dt><a name="40"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">nodeset complete</b></a></dt>
<dd></dd>
<dt><a name="41"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">nodeset topology</b></a></dt>
<dd><p>This method returns a bitmap, one of several NUMA node sets associated
with the element.</p>
<dl class="definitions">
<dt>allowed</dt>
<dd><p>All <i class="term">allowed</i> numa nodes.</p></dd>
<dt>complete</dt>
<dd><p>All numa nodes.</p></dd>
<dt>topology</dt>
<dd><p>All numa nodes of the system.</p></dd>
</dl></dd>
<dt><a name="42"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">parent</b></a></dt>
<dd><p>This method returns the identifier of the parent of the element.  The
method throws an error if the element is the root of the topology.</p></dd>
<dt><a name="43"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">prev_cousin</b></a></dt>
<dd><p>This method returns the identifier of the left sibling of the element,
if there is any, or the last child in the previous sibling of its
parent element. In essence it navigates to the left in its layer
without being bound to the children of the current parent.
The method throws an error if and only if the element is the first
element in its layer.</p></dd>
<dt><a name="44"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">prev_sibling</b></a></dt>
<dd><p>This method returns the identifier of the left sibling of the element.
The method throws an error if the element is the first child in its
parent, i.e. does not have a left sibling.</p></dd>
<dt><a name="45"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">sibling_rank</b></a></dt>
<dd><p>This method returns an integer number, the index of the element among
the children of its parent.</p></dd>
<dt><a name="46"><b class="cmd">topologyCmd</b> <b class="method">element</b> <i class="arg">id</i> <b class="method">type</b></a></dt>
<dd><p>This method returns a string, the type of the element.</p></dd>
<dt><a name="47"><b class="cmd">topologyCmd</b> <b class="method">element_by</b> <b class="option">-depth</b> <i class="arg">depth</i> <i class="arg">index</i></a></dt>
<dd></dd>
<dt><a name="48"><b class="cmd">topologyCmd</b> <b class="method">element_by</b> <b class="option">-type</b> <i class="arg">type</i> <i class="arg">index</i></a></dt>
<dd><p>This method is a constructor for element identifiers. Either directly
from <i class="arg">depth</i> and <i class="arg">index</i>, or the depth specified indirectly
through the element <i class="arg">type</i>.
An error is thrown if the intended element does not exist in the
topology.</p></dd>
<dt><a name="49"><b class="cmd">topologyCmd</b> <b class="method">root</b></a></dt>
<dd><p>This method returns the identifier for the root element of the
topology tree.</p></dd>
<dt><a name="50"><b class="cmd">topologyCmd</b> <b class="method">type</b> <i class="arg">depth</i></a></dt>
<dd><p>This method returns a string, the type of the elements at the
specified <i class="arg">depth</i> of the topology. An error is thrown if an
invalid depth is specified, i.e. either a value less than zero, or
greater than the value returned by</p>
<pre class="example">
    topology depth
</pre>
</dd>
<dt><a name="51"><b class="cmd">topologyCmd</b> <b class="method">width</b> <i class="arg">type</i></a></dt>
<dd></dd>
<dt><a name="52"><b class="cmd">topologyCmd</b> <b class="method">width</b> <i class="arg">depth</i></a></dt>
<dd><p>This method returns an integer value, the number of elements contained
in the topology which are of either the named <i class="arg">type</i>, or found at
the specified <i class="arg">depth</i>.</p>
<p>An error is thrown if an invalid depth is specified, i.e. either
a value less than zero, or greater than the value returned by</p>
<pre class="example">
    topology depth
</pre>
<p>Alternatively, an error is also thrown if an invalid <i class="arg">type</i>
is specified. The value <b class="const">0</b> is returned if the <i class="arg">type</i> is
valid but the topology does not contain elements of that type.</p></dd>
</dl>
</div>
<div id="section5" class="section"><h2><a name="section5">Bitmap API</a></h2>
<p>The methods in this section all deal with hwloc bitmaps, which are
used to represent sets of nodes, cpus, etc. An important thing to note
is that such bitmaps can be infinite, in the sense that a finite
header may be followed by an infinite trailer of 1-bits (with no
0-bits anymore).</p>
<dl class="definitions">
<dt><a name="53"><b class="cmd">hwloc bitmap</b> <b class="method">empty</b></a></dt>
<dd></dd>
<dt><a name="54"><b class="cmd">hwloc bitmap</b> <b class="method">full</b></a></dt>
<dd><p>These two methods return the empty (No bits set) and full (All bits set,
infinite) bitmaps, respectively.</p></dd>
<dt><a name="55"><b class="cmd">hwloc bitmap</b> <b class="method">allbut</b> <i class="arg">id</i></a></dt>
<dd></dd>
<dt><a name="56"><b class="cmd">hwloc bitmap</b> <b class="method">only</b> <i class="arg">id</i></a></dt>
<dd><p>These two methods return bitmaps with a single bit unset (<b class="method">allbut</b>)
or set (<b class="method">only</b>). The result of <b class="method">allbut</b> is an infinite bitmap.
The methods throw an error if a negative <i class="arg">id</i> is specified.</p></dd>
<dt><a name="57"><b class="cmd">hwloc bitmap</b> <b class="method">first</b> <i class="arg">bitmap</i></a></dt>
<dd><p>This method returns the id of the first set bit found in the <i class="arg">bitmap</i>,
counting up from bit 0. The method will throw an error if the <i class="arg">bitmap</i>
is empty, i.e. has no bit set at all.</p></dd>
<dt><a name="58"><b class="cmd">hwloc bitmap</b> <b class="method">last</b> <i class="arg">bitmap</i></a></dt>
<dd><p>This method returns the id of the last set bit found in the <i class="arg">bitmap</i>,
counting up from bit 0. The method will throw an error if the <i class="arg">bitmap</i>
is either empty, i.e. has no bit set at all, or infinite, i.e. has no
defined &quot;last&quot; bit.</p></dd>
<dt><a name="59"><b class="cmd">hwloc bitmap</b> <b class="method">next</b> <i class="arg">bitmap</i> <i class="arg">prev</i></a></dt>
<dd><p>This method, like <b class="method">first</b>, returns the id of the first set bit found
in the <i class="arg">bitmap</i>, however all bits up to and including bit <i class="arg">prev</i> are
ignored. Negative values for <i class="arg">prev</i> are allowed.</p>
<p>The method will throw an error if the <i class="arg">bitmap</i> is empty, i.e.
has no bit set at all, or if it is empty after bit <i class="arg">prev</i>.</p>
<p>The method <b class="method">first</b> is, in essence, the same as <b class="method">next</b>
called with &quot;prev == <b class="const">-1</b>&quot;, i.e.</p>
<pre class="example">
    [first bitmap] == [next bitmap -1]
</pre>
</dd>
<dt><a name="60"><b class="cmd">hwloc bitmap</b> <b class="method">from_ulong</b> <i class="arg">mask</i></a></dt>
<dd><p>This method takes an unsigned integer and converts it into a bitmap, based on
the integer's binary representation. The LSB is mapped to bit 0 of the bitmap.</p></dd>
<dt><a name="61"><b class="cmd">hwloc bitmap</b> <b class="method">to_ulong</b> <i class="arg">bitmap</i></a></dt>
<dd><p>This method is the complement to <b class="method">from_ulong</b>, converting the <i class="arg">bitmap</i>
into an unsigned integer value represented by the bits of the map.</p></dd>
<dt><a name="62"><b class="cmd">hwloc bitmap</b> <b class="method">is_empty</b> <i class="arg">bitmap</i></a></dt>
<dd></dd>
<dt><a name="63"><b class="cmd">hwloc bitmap</b> <b class="method">is_full</b> <i class="arg">bitmap</i></a></dt>
<dd><p>These two methods test if the specified <i class="arg">bitmap</i> is either the empty or the
full bitmap, i.e. no bits sets vs. all bits set, respectively. The result of the
methods is a boolean value, <b class="const">true</b> if the test succeeds, and <b class="const">false</b>
otherwise.</p></dd>
<dt><a name="64"><b class="cmd">hwloc bitmap</b> <b class="method">not</b> <i class="arg">bitmap</i></a></dt>
<dd><p>This method takes the <i class="arg">bitmap</i>, inverts all bits, and returns this as its
result.</p></dd>
<dt><a name="65"><b class="cmd">hwloc bitmap</b> <b class="method">singlify</b> <i class="arg">bitmap</i></a></dt>
<dd><p>This method is similar to <b class="method">first</b>, except that its result is a bitmap,
not a bit number, and it accepts the empty bitmap. In the resulting bitmap all
bits but the first set bit of the input are unset. If the input is empty the
output is simply empty as well.</p></dd>
<dt><a name="66"><b class="cmd">hwloc bitmap</b> <b class="method">weight</b> <i class="arg">bitmap</i></a></dt>
<dd><p>This method counts the number of set bits in the specified <i class="arg">bitmap</i> and
returns this as its result. The method will throw an error if the <i class="arg">bitmap</i>
is infinite, i.e. has not a bounded weight.</p></dd>
<dt><a name="67"><b class="cmd">hwloc bitmap</b> <b class="method">and</b> <i class="arg">bitmap1</i> <i class="arg">bitmap2</i></a></dt>
<dd></dd>
<dt><a name="68"><b class="cmd">hwloc bitmap</b> <b class="method">andnot</b> <i class="arg">bitmap1</i> <i class="arg">bitmap2</i></a></dt>
<dd></dd>
<dt><a name="69"><b class="cmd">hwloc bitmap</b> <b class="method">or</b> <i class="arg">bitmap1</i> <i class="arg">bitmap2</i></a></dt>
<dd></dd>
<dt><a name="70"><b class="cmd">hwloc bitmap</b> <b class="method">xor</b> <i class="arg">bitmap1</i> <i class="arg">bitmap2</i></a></dt>
<dd><p>These four methods perform standard bitwise operations on the two bitmaps,
returning the operations' result. See the following mapping to C expressions:</p>
<pre class="example">
    and    A B == A &amp; B
    andnot A B == A &amp; ~B
    or     A B == A | B
    xor    A B == A ^ B
</pre>
</dd>
<dt><a name="71"><b class="cmd">hwloc bitmap</b> <b class="method">is_equal</b> <i class="arg">bitmap1</i> <i class="arg">bitmap2</i></a></dt>
<dd><p>This method tests if the two specified bitmaps are equal in all respects.
The result of the method is a boolean value, <b class="const">true</b> if the bitmaps
are equal, and <b class="const">false</b> otherwise.</p></dd>
<dt><a name="72"><b class="cmd">hwloc bitmap</b> <b class="method">is_included</b> <i class="arg">bitmapsub</i> <i class="arg">bitmapsuper</i></a></dt>
<dd><p>This method tests if <i class="arg">bitmapsub</i> is a subset of <i class="arg">bitmapsuper</i>.
The result of the method is a boolean value, <b class="const">true</b> if the bitmap
is a subset, and <b class="const">false</b> otherwise.</p></dd>
<dt><a name="73"><b class="cmd">hwloc bitmap</b> <b class="method">compare</b> <i class="arg">bitmap1</i> <i class="arg">bitmap2</i></a></dt>
<dd></dd>
<dt><a name="74"><b class="cmd">hwloc bitmap</b> <b class="method">compare_first</b> <i class="arg">bitmap1</i> <i class="arg">bitmap2</i></a></dt>
<dd><p>These two method compare the two bitmaps by comparing the last and first set
bits respectively. The result of the methods are the difference between the
ids of these bits. The empty bitmap is treated as if it had bit <b class="const">-1</b> set.</p></dd>
<dt><a name="75"><b class="cmd">hwloc bitmap</b> <b class="method">intersects</b> <i class="arg">bitmap1</i> <i class="arg">bitmap2</i></a></dt>
<dd><p>This method tests if the two specified bitmaps intersect with each other, i.e if
the result of <b class="method">and</b>'ing them together is not empty. The result of the method
is a boolean value, <b class="const">true</b> if the bitmaps have a non-empty intersection,
and <b class="const">false</b> otherwise.</p></dd>
<dt><a name="76"><b class="cmd">hwloc bitmap</b> <b class="method">set</b> <i class="arg">bitmap</i> <i class="arg">id</i></a></dt>
<dd></dd>
<dt><a name="77"><b class="cmd">hwloc bitmap</b> <b class="method">clear</b> <i class="arg">bitmap</i> <i class="arg">id</i></a></dt>
<dd></dd>
<dt><a name="78"><b class="cmd">hwloc bitmap</b> <b class="method">is_set</b> <i class="arg">bitmap</i> <i class="arg">id</i></a></dt>
<dd><p>These three methods set, unset, and test the bits in a <i class="arg">bitmap</i>. The
first two methods return the modified bitmap as result, whereas the last
returns a boolean value, <b class="const">true</b> if the bit is set, and <i class="arg">false</i>
otherwise. The methods throw an error if a negative <i class="arg">id</i> is specified.</p></dd>
<dt><a name="79"><b class="cmd">hwloc bitmap</b> <b class="method">set_range</b> <i class="arg">bitmap</i> <i class="arg">begin</i> <i class="arg">end</i></a></dt>
<dd></dd>
<dt><a name="80"><b class="cmd">hwloc bitmap</b> <b class="method">clear_range</b> <i class="arg">bitmap</i> <i class="arg">begin</i> <i class="arg">end</i></a></dt>
<dd><p>These two methods are extensions of the modifiers in the previous group from
single bits to bit ranges. The range of bits to set or clear is specified by two
bit ids. The methods return the modified bitmap as their result.
The methods throw an error if a negative id is specified, for either <i class="arg">begin</i>
or <i class="arg">end</i>. Specifying an <i class="arg">end</i> &lt; <i class="arg">begin</i> is acceptable however, this
specifies an empty range and the method will return the unmodified <i class="arg">bitmap</i>.</p></dd>
</dl>
</div>
<div id="section6" class="section"><h2><a name="section6">Element Identifiers</a></h2>
<p>As explained in section <span class="sectref"><a href="#section2">Concepts</a></span> in more detail, the
elements of a topology instance are organized in a combination of tree
and matrix, with the tree structure providing the information about
nesting (containment), and the matrix providing direct addressability.</p>
<p>The element identifiers used by the package are based on the
latter, identifying each element by depth and index in that layer. A
valid element identifier follows the rules below:</p>
<ol class="enumerated">
<li><p>It is a list containing exactly two elements.</p></li>
<li><p>Each element is an integer number.</p></li>
<li><p>The first element is the depth of the element in the topology,
       counted from <b class="const">0</b>, with <b class="const">0</b> refering to the topmost
       layer, the <i class="term">root</i> layer, and increasing as we move deeper
       down. The maximum allowed value is one less than the result of
       the instance method <b class="method">depth</b> (without arguments).</p></li>
<li><p>The second element is the index of the element in its layer,
       counted from <b class="const">0</b>, with <b class="const">0</b> refering to the leftmost
       element, and increasing as we move to the right. The maximum
       allowed value is one less than the result of the instance
       method <b class="method">width</b> for the specified depth.</p></li>
</ol>
</div>
<div id="section7" class="section"><h2><a name="section7">References</a></h2>
<ol class="enumerated">
<li><p><a href="http://www.open-mpi.org/projects/hwloc/">Portable Hardware Locality</a></p></li>
</ol>
</div>
<div id="keywords" class="section"><h2><a name="keywords">Keywords</a></h2>
<p>beowulf, binding cpu, binding memory, cache, cpu binding, hardware Locality, hwloc, memory binding, multi-core, numa, parallel, portable hardware locality, process, processing unit, thread</p>
</div>
<div id="copyright" class="section"><h2><a name="copyright">Copyright</a></h2>
<p>Copyright &copy; 2011 George Andreou, Andreas Kupries<br>
Copyright &copy; 2011 Documentation, Andreas Kupries</p>
</div>
</div></body></html>
